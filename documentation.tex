% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.3 for LaTeX2e
%
\nocite{*}
\documentclass{llncs}
%
\usepackage{ngerman}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{multirow}
\usepackage{rotating}
\usepackage{verbatim}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{amssymb}   % AMS-Sonderzeichen
\usepackage{tabularx}  % Für tabularx und newcolumntype
% \usepackage[paper=a4paper,left=30mm,right=30mm,top=30mm,bottom=30mm]{geometry}
\usepackage{color}
\usepackage{ragged2e}
\usepackage{ifpdf}
% \usepackage{titlesec}
\usepackage{xcolor}    % Lieber xcolor als color. Dann klappt auch das listings gut mit den Farben
\usepackage{listings}
\usepackage{upquote}   % Verändert die Ausgabe der einfachen Anführungszeichen innerhalb von verbatim
\usepackage{eurosym}   % Euro-Zeichen: \euro
\usepackage{lastpage}  % \pageref{LastPage} um die Anzahl der Seiten zu erhalten
% hiermit kann man auch umlaute copy-pasten
\usepackage{lmodern}
\selectlanguage{german}
\usepackage{fancyhdr}
\pagestyle{fancy}
%

\lstset{
language=Python,
captionpos=b, 
caption=Funktion update\_matchfield() aktualiersiert die visuelle Darstellung, 
label=QuellcodeBeispielNr1,
basicstyle=\ttfamily\footnotesize,      % Code font, Examples: \footnotesize, \ttfamily
keywordstyle=\color{FrankfurtBlue},     % Keywords font ('*' = uppercase)
commentstyle=\color{gray},              % Comments font
numbers=left,                           % Line nums position
numberstyle=\footnotesize,              % Line-numbers fonts
stepnumber=1,                           % Step between two line-numbers
numbersep=5pt,                          % How far are line-numbers from code
backgroundcolor=\color{lightlightgray}, % Choose background color
frame=none,                             % A frame around the code
tabsize=2,                              % Default tab size
captionpos=b,                           % Caption-position = bottom
breaklines=true,                        % Automatic line breaking?
breakatwhitespace=false,                % Automatic breaks only at whitespace?
showspaces=false,                       % Dont make spaces visible
showstringspaces=false                  %
showtabs=false,                         % Dont make tabls visible
columns=fixed,                          % Column format
morekeywords={},                        % Specific keywords}
literate=%
{Ö}{{\"O}}1
{Ä}{{\"A}}1
{Ü}{{\"U}}1
{ö}{{\"o}}1
{ä}{{\"a}}1
{ü}{{\"u}}1
{ß}{{\ss}}1
{~}{{\textasciitilde}}1
}

\ifpdf
\pdfinfo{
  /Author (Marc Ullmann, David Ruschmaritsch, Anne Lotte Müller-Kühlkamp)
  /Title  (Schifferversenken in Python --Werkstück A-- SS2021)
  /Subject (Betriebssysteme, Rechnernetze)
  /Keywords (Betriebssysteme, Rechnernetze, Werkstück A, SS2021)
}
\fi

\setlength{\parindent}{0pt}    % Erste Zeile eines Absatzes nicht einrücken
\parskip2ex                    % Absatzabstand
\setlength{\itemsep}{0ex plus0.2ex}
\sloppy                        % Auf jeden Fall die Seitenränder einhalten.

\newcommand{\was}{Schiffeversenken in Python}
\newcommand{\wer}{Marc Ullmann, David Ruschmaritsch, Anne Lotte Müller-Kühlkamp}
\newcommand{\wann}{SS2021}

\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\lhead[\wann]{\wer}
\rhead[\wer]{\wann}
\chead[]{}
\lfoot[Seite \thepage\ von \pageref{LastPage}]{\was}
\rfoot[\was]{Seite \thepage\ von \pageref{LastPage}}
\cfoot[]{}
\pagestyle{fancy}


% Hurenkinder und Schusterjungen komplett verbieten.
\clubpenalty = 10000 
\widowpenalty = 10000 
\displaywidowpenalty = 10000
% Diese Begriffe bezeichnen den Makel beim Textsatz, wenn eine Seite mit der ersten Zeile eines Absatzes endet (so genannter Schusterjunge) oder eine neue Seite mit der letzten Zeile eines Absatzes beginnt (so genanntes Hurenkind).


% Wir definieren ein paar Farben
\definecolor{Brown}{cmyk}{0,0.81,1,0.60}
\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{CadetBlue}{cmyk}{0.62,0.57,0.23,0}
\definecolor{lightlightgray}{gray}{0.9}
\definecolor{FrankfurtBlue}{HTML}{3333b2}

% Hier fängt das Dokument an!
\begin{document}

%
% \frontmatter          % for the preliminaries
%
% \tableofcontents
%
\mainmatter              % start of the contributions
%
\title{Schiffeversenken in Python - SS2021}
%
\author{Marc Ullmann, David Ruschmaritsch, Anne Lotte Müller-Kühlkamp}
%
\institute{
Frankfurt University of Applied Sciences\\
(1971-2021: Fachhochschule Frankfurt am Main)\\
Nibelungenplatz 1\\
60318 Frankfurt am Main\\
\email{marc.ullmann@stud.fra-uas.de, david.ruschmaritsch@stud.fra-uas.de, anne.mueller-kuehlkamp@stud.fra-uas.de}
}

\maketitle              % typeset the title of the contribution

\begin{abstract}
Hier kommt das Abstract hin. Das Abstract sollte in wenigen Sätzen (weniger als 10 Zeilen) den Inhalt des Dokuments beschreiben. Wikipedia schreibt: Ein Abstract ist eine prägnante Inhaltsangabe, ein Abriss ohne Interpretation und Wertung einer wissenschaftlichen Arbeit. Das Abstract soll so kurz wie möglich sein. Alle wesentlichen Sachverhalte sollen explizit enthalten sein. Das Abstract soll beim Leser Interesse für den Inhalt des Dokuments wecken.
\end{abstract}

Das Spiel Schiffeversenken, welches früher nur mit Stift und Papier gespielt wurde und sich seit dem in seiner Grundstruktur kaum verändert hat, bietet in der Implementierung die optimalen Grundlagen der objektorientierten Programmierung und
grafischen Darstellung.

\section{Grundprinzip Schiffeversenken}

Für die Implementierung des Spiels wird ein Spielfeld benötigt, welches mit Kommandozeilenargumenten anpassbar sein soll. Die Beschränkung von einer Mindestgröße von 10x10 Feldern und Maximalgröße von 20x20
Feldern erwies sich als sinnvoll, da bei mehr als 20 Feldern die Größe des Standard-Fenster überschritten wird und somit das Programm abstürzt.
Bei weniger als zehn Feldern könnte es zu Platzproblemen der Schiffe mit dem Platzier-Algorithmus geben und somit unerwünschte Ereignisse hervorrufen.
Deshalb wird bei Eingabe von zwei Kommandozeilenargumenten die Begrenzung abgefragt, die bei Abweichung die Standardgröße von 10x10 wählt.
Für die Implementierung von Schiffen ist nun die Grundlage des Spielfelds gegeben. Ein Schiff ist als Objekt zu definieren.
Die Schiffanzahl ist von Grund auf festgelegt auf insgesamt zehn Schiffe~\cite{Schiffeversenken}:
\begin{itemize}
  \item 1x Schlachtschiff mit Größe 5
  \item 2x Kreuzer mit Größe 4
  \item 3x Zerstörer mit Größe 3
  \item 4x U-Boote mit Größe 2
\end{itemize}

\section{Visuelle Darstellung}

Zu Beginn kam es zur Wahl der Bibliothek für die visuelle Darstellung. Zuerst fiel diese auf termbox~\cite{Termbox}. Da diese jedoch nicht mehr unterstützt und weiterentwickelt wird, fiel die Entscheidung zuerst auf cursebox~\cite{Cursebox}, für welche
die einfachen Befehle und praktische Funktionen sprachen. Da auch diese nicht weiterhin unterstützt wird und wenig Dokumentation zu der Bibliothek vorliegt, wurde das Programm in curses~\cite{Curses} übersetzt.

\subsection{Spielfeld}

Das Spielfeld wurde mit Hilfe von der Erweiterung numpy~\cite{Numpy} entwickelt. Die Erweiterung bietet eine einfache Erstellung mehrdimensionaler Arrays und liefert verschiedene Operationen um diese zu konfigurieren.
Ein zweidimensionales Array bietet die optimale Grundlage für das Spielfeld, da dies wie ein 2D-Koordinatensystem betrachtet werden kann.
Mit einem Null-Array (numpy.zeroes) ist es nur möglich Zahlen zu verarbeiten. Dies hat zur Auswirkung, dass Felder die beispielsweise mit Schiffen belegt sind, durch eine \glqq 1\grqq{} und Felder ohne Schiffe eine \glqq 0\grqq{} repräsentiert werden.
Dadurch ist es einfacher Felder zu vergleichen, da diese nur mit Zahlen belegt sind und nicht weiter übersetzt werden müssen. Für die grafische Darstellung des Null-Arrays bedeutet dies jedoch, eine Einschränkung um die
Objekte ansehnlich darzustellen. 
Das Chararray, welches Zeichen speichern kann, bietet sich hier an. Jedoch wird bei der Darstellung des Arrays immer ein \glqq b\grqq{} für Byte hinzugefügt, da es Bytestrings sind, die in dem Array gespeichert werden. 
Dies wurde umgangen indem der Datentyp des Arrays als Zeichenkette übersetzt und dann ausgegeben wird. Für die Darstellung eines Spielfeldes und nicht der Hinternanderreihung einzelner Objekte des Arrays, wird jede Reihe des 
Arrays einzeln in einer eigenen Zeile ausgegeben.

Um die Vorteile beider Arrays zu benutzen, müssen verschiedene Arrays erstellt werden. Insgesamt gibt es fünf Arrays: Zwei Charrays für die grafische Darstellung und drei Null-Arrays für die logische Verarbeitung.

\subsection{Spielfeld: Schiffplatzierung}

In diesem Fall wird nur das eine Charray benutzt, welches die ersten beiden logischen Arrays der Schiffplatzierung visuell übersetzt. Dafür wird ein \glqq *\grqq{} (logisch=2) für die aktuelle Position des Schiffs und ein \glqq X\grqq{} (logisch=1)
für schon platzierte Schiffe benutzt. Die leeren Felder werden durch \glqq O\grqq{} (logisch=0) dargestellt.

\subsection{Spielfeld: Beschuss}

Nach der Platzierung der Schiffe wird nun abwechselnt gefeuert. Dafür werden nun durchgehend zwei Spielfelder (durch die beiden Chararrays) angezeigt. Das linke zeigt dabei das Spielfeld des Gegners an, auf welchem die aktuelle Position und
schon beschossene Felder angezeigt werden. Dafür werden die bereits Getroffenen als \glqq *\grqq{} (logisch=2), Wassertreffer als \glqq Prozentzeichen\grqq{} (logisch=3), das Aktuelle als \glqq X\grqq{} (logisch=1) und Leere als \glqq O\grqq{} (logisch=0)
angezeigt. Das rechte Spieldfeld zeigt das eigene Spielfeld, mit allen Schiffpositionen und Schüssen des Gegners, an. An der oberen Seite wird der aktuelle Spieler und dessen verbleibenden Schiffe angezeigt, an
der unteren die des Gegners. 

\subsection{Sonstige visuelle Elemente}

Um die Bedienung zu erleichtern, werden am unteren Ende die aktuell möglichen Eingaben angezeigt.

\subsection{Die Funktion \emph{update\_matchfield()}}

Diese Funktion ist für den großteil der visuellen Darstellung verantwortlich. Ihre Aufgabe ist es, den aktuellen Spieler anzuzeigen, die logischen in die visuellen Arrays zu übersetzen
und einige visuelle Elemente hinzuzufügen. Der aktuelle Spieler wird der Funktion als Parameter übergeben und dann ausgegeben.

Um ein Spielfeld zu übersetzen, wird der Funktion immer ein Charray (visuelles Spielfeld) und ein Null-Array (logisches Spielfeld) übergeben. Um zwei Spielfelder darzustellen,
wird die Funktion zwei mal aufgerufen. Dies stellt ein vor das Problem, dass der aktuelle Bildschirm nicht komplett gelöscht werden kann, sondern aktuelle Elemente nur überschrieben
werden können. Das heißt alle Elemente die nicht genau übereinanderliegen, müssen durch ein leeren String ersetzt werden. Da das Spielfeld des Gegners und des aktuellen Spielers
immer an der gleichen Position liegen, überschreiben diese sich automatisch. Andere Elemente wie die Anzahl der Schiffe und die Anzeige der Eingaben werden in eigenen Funktionen aufgrufen.

Mit zwei for-Schleifen wird das logische Spielfeld Schritt für Schritt in das Visuelle übersetzt. Zudem gibt es eine Änderung wenn man gegen den Computer spielt. Da das Feld von diesem,
auch für den menschlichen Spieler sichtbar ist, werden seine Schiffspositionen verdeckt. Dies ermöglicht dem Spieler direkt zu sehen, worauf der Computer schießt. 
An den Rändern der Spielfelder wird durch Sonderzeichen das Spielfeld abgegrenzt, wodurch der Überblick erleichtert wird. Zudem sind die Seiten für die Texteingabe durchgehend nummeriert.

\section{Mausimplementation}

Grundsätzlich soll das Spiel mit der Tastatur spielbar sein, jedoch gab es in den Anforderungen auch die Wahl eine Maussteuerung einzubinden.
Die benutzte Programmbibliothek \glqq curses\grqq{}, welche zur Darstellung zeichenorientierter Benutzerschnittstellen unabhängig vom darstellenden Textterminal ist,
bietet hierzu die Funktion \glqq getMouse()\grqq{} an. Diese Funktion liefert ein 5-stelliges Tupel. Darin enthalten sind unter Anderem die x- und y-Koordinaten der Maus,
welche mit einem Tastenereignis (hier ein Mausklick) abzufragen sind. Nun gilt es die in dem curses-Terminal dargestellten Texte, welche als Knöpfe dienen sollen,
per Mausklick zu aktivieren. Dazu müssen die Koordinaten der Maus mit denen der dargestellten Texte übereinstimmen. Dies erwies sich als umständlich und komplex für die
weitere Implementierung des Spiels, da die dargestellten Strings keine Objekte sind und damit keine Funktionen zur Abfrage und dem damit verbundenen Vergleich der Mausposition hatten und man diese aufwendig herausfinden müsste.
Deshalb funktioniert die Maus nur im Anfangsmenü.

\section{Benutzereingaben}

Für die Entgegennahme der Eingaben des Benutzers wurde die Funktion \glqq userinput()\grqq{} entwickelt, welche die gedrückte Taste (oder Maus) entgegen nimmt.
Die Eingabeerkennung wird mit der curses-Funktion \glqq get\_wch()\grqq{} erzeugt. Diese gibt Zeichen für die meisten Tasten zurück.
Bei der Eingabe wird festgelegt, welche Tasten für welche Richtungen verantwortlich sind. Die obere Pfeiltaste und die Taste \glqq w\grqq{} ist so beispielsweise für die Richtung Norden.

\lstset{
caption=Funktion userinput() nimmt Eingaben des Benutzers an}
\begin{lstlisting}
def userinput(screen):
''' Checks user input '''
input_key = ""
curinput = ""
screen.keypad(1)
curses.mousemask(-1)

curinput = screen.get_wch()

if curinput == 'd' or curinput == curses.KEY_RIGHT:
    input_key = "right"
elif curinput == 's' or curinput == curses.KEY_DOWN:
    input_key = "down"
elif curinput == 'a' or curinput == curses.KEY_LEFT:
    input_key = "left"
elif curinput == 'w' or curinput == curses.KEY_UP:
    input_key = "up"
elif curinput == '\n':
    input_key = "enter"
elif curinput == curses.KEY_MOUSE:
    input_key = "mouse"
else: 
    input_key = curinput
return input_key
\end{lstlisting}

\section{Die Klasse Ship}

Alle Schiffe sind als Objekte definiert. Objekte bieten hier einen erheblichen Vorteil durch deren Attribute.
In jedem Schiff werden die Größe, Rotation, Startposition und Koordinaten gespeichert. Die Koordinaten berechnen sich durch die Objektmethode \glqq ship\_cords\grqq{}, welche 
je nach Ausrichtung (horizontal, vertikal) eine Schleife bis zur Größe des Schiffs durchläuft und von der Startkoordinate aus in die jeweilige Richtung läuft.

\section{Schiffplatzierung}

Das erste logische Array speichert die temporären Daten, welche für die Berechnungen von der Spielfeldbegrenzung dienen. Das zweite speichert tempöräre Daten, wenn diese die Regeln nicht verletzen.
Für die Platzierung der Schiffe wird nun in dem tempörären Array bestimmt, ob die Schiffsgröße die Spielfeldgröße überschreitet. Wenn schon Schiffe platziert wurden gleicht es zudem mit dem zweiten logischen
Array die Position dieser ab und berechnet so die Möglichkeit der Platzierung. Bei der Platzierung werden die umliegenden Felder reserviert, da die Schiffe sich nicht direkt berühren dürfen. Das dritte logische 
Array speichert hingegen nur die Schiffspositionen ab, um diese später zu übergeben.

\section{Die Funktion \emph{shoot()}}

Nachdem der Spieler die Schiffe platziert hat. Beginnt das eigentliche Spiel, nämlich der Beschuss des Gegners. Der Spieler kann mit WASD, Pfeiltasten oder durch Eingabe \(e\) entscheiden,
welches Feld beschossen werden soll. Dies wird mit der Taste \glqq enter\grqq{} bestätigt. Mit dem Tastendruck wird zuerst geprüft, ob dieses Feld bereits beschossen wurde.
Dies gilt nicht für den ersten Schuss, da bisher kein Feld beschossen wurde. Trifft der Schuss kein Schiff aber ein gültiges Feld, so wird das Feld im logischen Array mit einer \glqq 3\grqq{} belegt.
Trifft der Schuss jedoch ein Schiff, wird das getroffene Schiff mit Koordinatenabgleich identifiziert und das getroffene Feld aus den Koordinaten des Schiffs gelöscht.
Sobald alle Felder des Schiffs getroffen wurden wird das Schiffobjekt aus der ship\_list\_placed Liste gelöscht. Bei zerstörten Schiffen werden die naheliegenden Felder reserviert,
da sich dort keine Schiffe mehr befinden können.

% ---- Bibliography ----
\begin{thebibliography}{5}

\bibitem{Schiffeversenken}
Schiffeversenken. wikipedia.org. 2021\\
\url{https://github.com/nsf/termbox}
\bibitem{Termbox}
nsf. Termbox. Github. 2020\\
\url{https://github.com/nsf/termbox}
\bibitem{Cursebox}
Tenchi2xh. Cursebox. github.com. 2018\\
\url{https://github.com/Tenchi2xh/cursebox}
\bibitem{Curses}
A.M. Kuchling, Eric S. Raymond, Curses, python.org. 2021\\
\url{https://docs.python.org/3/howto/curses.html}
\bibitem{Numpy}
Numpy, numpy.org. 2021\\
\url{https://numpy.org/}
\end{thebibliography}
\end{document}
